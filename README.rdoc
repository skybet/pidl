# :markup: markdown
# :title: Pidl - PIpeline Definition Language
#
# # Pidl
#
# The PIpeline Definition Language provides a simple way to script pipelines of
# work to do just about anything. Each pipeline is broken down into tasks, and
# each task is broken down into actions. The actions can be built quickly and
# easily and perform just about any task imaginable.
#
# # Getting Started
#
# Pidl pipelines are defined by a very simple, Ruby-esque DSL that should be
# familiar with anyone who has used a Ruby DSL before. There are a handful of
# simple constructs already created to get your first pipeline started.
#
#     require 'pidl'
#
#     context # Pidl::Context.new
#     pipeline # Pidl::Pipeline.new 'My Pipeline', context do
#
#       task :first_task do
#         # Put actions in here
#       end
#
#       task :second_task do
#         after :first_task
#       end
#
#       task :third_task do
#         after :first_task
#       end
#
#       task :fourth_task do
#         after :first_task, :third_task
#       end
#
#       on_error do
#         # Put error cleanup in here
#       end
#
#     end
#
# This pipeline will do absolutely nothing, but it will let us explore some
# important aspects of the system.
#
# ## Running the Pipeline
#
# Running the pipeline is achieved by calling Pidl::Pipeline#run.
#
#     pipeline.run
#
# The #run method will calculate the optimal grouping of tasks to ensure
# dependencies are satisfied (more on those later) and execute all the tasks,
# parallelising where possible.
#
# ## Explain Plan
#
# In order to find out what the optimal grouping of tasks is that the run
# method discovered, call instead the Pidl::Pipeline#explain method. This will
# return an array of arrays containing groupings of tasks in the order they
# should be run.
#
# Executing #explain provides the following explain plan:
#
# ``` ruby
# [
#   [ first_task ],
#   [ second_task, third_task ],
#   [ fourth_task ]
# ]
# ```
#
# Each group is a set of concurrent tasks. The first and third group only
# contain one, but the second group has two, meaning that :second_task and
# :third_task can be run concurrently because they do not depend on each other.
#
# The Pidl::Pipeline#explain method also catches unreachable tasks and
# recursive dependencies so you can be sure that the plan is sane.
#
# A similar tool is Pidl::Pipeline#dry_run, which outputs a description of the
# pipeline, each task and each action explaining exactly what the configured
# parameters will do.
#
# ```
# Pipeline:My Pipeline
#   Task:first_task
#   Task:second_task
# ```
#
# # Creating An Action
#
# All actions are created as subclasses of the Pidl::Action class. A basic task that does nothing but output its name may look like this:
#
# ``` ruby
# class MeAction < Pidl::Action
#
#   setter :surname
#
#   def run
#     case @action
#     when :print
#       puts "#{@name} #{@surname}"
#     end
#   end
#
#   def dry_run indent=""
#     case @action
#     when :print
#       puts "#{indent}#{basename}: Print name [#{@name}] with surname [#{surname}]"
#     end
#   end
#
# end
# ```
#
# Including this action in the DSL means adding it to the pipeline:
#
# ``` ruby
# acts = {
#   me: MeAction
# }
# pipeline = Pidl::Pipeline.new "My Pipeline", context, actions: acts do
#   task :first_task do
#     me "Joe" do
#       action :print
#       surname "Bloggs"
#     end
#   end
# end
# pipeline.dry_run
# ```
#
# The output appears thus:
#
# ```
# Pipeline:My Pipeline
#   Task:first_task
#     MeAction: Print name [Joe] with surname [Bloggs]
# ```
#
# Running the pipeline results in the output "Joe Bloggs", as you might expect.
#
# Read Pidl::Action for more information about validation and other types of
# command that can be added to an action.
#
# # Context
#
#
